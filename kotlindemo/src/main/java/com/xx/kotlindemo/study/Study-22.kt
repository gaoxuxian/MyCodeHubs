package com.xx.kotlindemo.study

/**
 * 扩展 part two
 *
 * 扩展是静态解析的
 */
open class D

class E: D() {
    fun foo() = "E"
}

fun D.foo() = "d"

fun E.foo() = "e"

fun printFoo(d: D) {

    /**
     * 扩展不能真正的修改他们所扩展的类。
     *
     * 通过定义一个扩展，你并没有在一个类中插入新成员，仅仅是可以通过该类型的变量用点表达式去调用这个新函数。
     *
     * 我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。
     *
     * 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的，而不是由表达式运行时求值结果决定的。
     */

    println(d.foo())
}

fun main() {
    printFoo(E()) // 输出 d，因为调用的扩展函数只取决于参数 d 的声明类型，该类型是 D 类。
    println(E().foo()) // 输出 E，如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字，都适用给定的参数，这种情况总是取 成员函数
}